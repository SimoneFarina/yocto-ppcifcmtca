diff -up openssh-7.4p1/authfd.c.openssl openssh-7.4p1/authfd.c
--- openssh-7.4p1/authfd.c.openssl	2016-12-19 05:59:41.000000000 +0100
+++ openssh-7.4p1/authfd.c	2016-12-23 17:47:36.429817751 +0100
@@ -207,15 +207,22 @@ deserialise_identity1(struct sshbuf *ids
 	int r, keybits;
 	u_int32_t bits;
 	char *comment = NULL;
+	BIGNUM *e = NULL, *n = NULL;
 
 	if ((key = sshkey_new(KEY_RSA1)) == NULL)
 		return SSH_ERR_ALLOC_FAIL;
-	if ((r = sshbuf_get_u32(ids, &bits)) != 0 ||
-	    (r = sshbuf_get_bignum1(ids, key->rsa->e)) != 0 ||
-	    (r = sshbuf_get_bignum1(ids, key->rsa->n)) != 0 ||
-	    (r = sshbuf_get_cstring(ids, &comment, NULL)) != 0)
+	if ((e = BN_new()) == NULL ||
+	    (n = BN_new()) == NULL ||
+	    (r = sshbuf_get_u32(ids, &bits)) != 0 ||
+	    (r = sshbuf_get_bignum1(ids, e)) != 0 ||
+	    (r = sshbuf_get_bignum1(ids, n)) != 0 ||
+	    (RSA_set0_key(key->rsa, n, e, NULL) == 0) ||
+	    (r = sshbuf_get_cstring(ids, &comment, NULL)) != 0) {
+		BN_free(n);
+		BN_free(e);
 		goto out;
-	keybits = BN_num_bits(key->rsa->n);
+	}
+	keybits = BN_num_bits(n);
 	/* XXX previously we just warned here. I think we should be strict */
 	if (keybits < 0 || bits != (u_int)keybits) {
 		r = SSH_ERR_KEY_BITS_MISMATCH;
@@ -393,15 +400,17 @@ ssh_decrypt_challenge(int sock, struct s
 	struct sshbuf *msg;
 	int r;
 	u_char type;
+	const BIGNUM *e, *n;
 
 	if (key->type != KEY_RSA1)
 		return SSH_ERR_INVALID_ARGUMENT;
 	if ((msg = sshbuf_new()) == NULL)
 		return SSH_ERR_ALLOC_FAIL;
+	RSA_get0_key(key->rsa, &n, &e, NULL);
 	if ((r = sshbuf_put_u8(msg, SSH_AGENTC_RSA_CHALLENGE)) != 0 ||
-	    (r = sshbuf_put_u32(msg, BN_num_bits(key->rsa->n))) != 0 ||
-	    (r = sshbuf_put_bignum1(msg, key->rsa->e)) != 0 ||
-	    (r = sshbuf_put_bignum1(msg, key->rsa->n)) != 0 ||
+	    (r = sshbuf_put_u32(msg, BN_num_bits(n))) != 0 ||
+	    (r = sshbuf_put_bignum1(msg, e)) != 0 ||
+	    (r = sshbuf_put_bignum1(msg, n)) != 0 ||
 	    (r = sshbuf_put_bignum1(msg, challenge)) != 0 ||
 	    (r = sshbuf_put(msg, session_id, 16)) != 0 ||
 	    (r = sshbuf_put_u32(msg, 1)) != 0) /* Response type for proto 1.1 */
@@ -499,15 +508,19 @@ static int
 ssh_encode_identity_rsa1(struct sshbuf *b, RSA *key, const char *comment)
 {
 	int r;
+	const BIGNUM *n, *e, *d, *q, *p, *iqmp;
 
+	RSA_get0_key(key, &n, &e, &d);
+	RSA_get0_factors(key, &p, &q);
+	RSA_get0_crt_params(key, NULL, NULL, &iqmp);
 	/* To keep within the protocol: p < q for ssh. in SSL p > q */
-	if ((r = sshbuf_put_u32(b, BN_num_bits(key->n))) != 0 ||
-	    (r = sshbuf_put_bignum1(b, key->n)) != 0 ||
-	    (r = sshbuf_put_bignum1(b, key->e)) != 0 ||
-	    (r = sshbuf_put_bignum1(b, key->d)) != 0 ||
-	    (r = sshbuf_put_bignum1(b, key->iqmp)) != 0 ||
-	    (r = sshbuf_put_bignum1(b, key->q)) != 0 ||
-	    (r = sshbuf_put_bignum1(b, key->p)) != 0 ||
+	if ((r = sshbuf_put_u32(b, BN_num_bits(n))) != 0 ||
+	    (r = sshbuf_put_bignum1(b, n)) != 0 ||
+	    (r = sshbuf_put_bignum1(b, e)) != 0 ||
+	    (r = sshbuf_put_bignum1(b, d)) != 0 ||
+	    (r = sshbuf_put_bignum1(b, iqmp)) != 0 ||
+	    (r = sshbuf_put_bignum1(b, q)) != 0 ||
+	    (r = sshbuf_put_bignum1(b, p)) != 0 ||
 	    (r = sshbuf_put_cstring(b, comment)) != 0)
 		return r;
 	return 0;
@@ -622,11 +635,13 @@ ssh_remove_identity(int sock, struct ssh
 
 #ifdef WITH_SSH1
 	if (key->type == KEY_RSA1) {
+		const BIGNUM *e, *n;
+		RSA_get0_key(key->rsa, &n, &e, NULL);
 		if ((r = sshbuf_put_u8(msg,
 		    SSH_AGENTC_REMOVE_RSA_IDENTITY)) != 0 ||
-		    (r = sshbuf_put_u32(msg, BN_num_bits(key->rsa->n))) != 0 ||
-		    (r = sshbuf_put_bignum1(msg, key->rsa->e)) != 0 ||
-		    (r = sshbuf_put_bignum1(msg, key->rsa->n)) != 0)
+		    (r = sshbuf_put_u32(msg, BN_num_bits(n))) != 0 ||
+		    (r = sshbuf_put_bignum1(msg, e)) != 0 ||
+		    (r = sshbuf_put_bignum1(msg, n)) != 0)
 			goto out;
 	} else
 #endif
diff -up openssh-7.4p1/auth-pam.c.openssl openssh-7.4p1/auth-pam.c
--- openssh-7.4p1/auth-pam.c.openssl	2016-12-23 17:47:36.400817739 +0100
+++ openssh-7.4p1/auth-pam.c	2016-12-23 17:47:36.430817752 +0100
@@ -129,6 +129,10 @@ extern u_int utmp_len;
 typedef pthread_t sp_pthread_t;
 #else
 typedef pid_t sp_pthread_t;
+# define pthread_create(a, b, c, d)	_ssh_compat_pthread_create(a, b, c, d)
+# define pthread_exit(a)		_ssh_compat_pthread_exit(a)
+# define pthread_cancel(a)		_ssh_compat_pthread_cancel(a)
+# define pthread_join(a, b)		_ssh_compat_pthread_join(a, b)
 #endif
 
 struct pam_ctxt {
diff -up openssh-7.4p1/cipher-3des1.c.openssl openssh-7.4p1/cipher-3des1.c
--- openssh-7.4p1/cipher-3des1.c.openssl	2016-12-19 05:59:41.000000000 +0100
+++ openssh-7.4p1/cipher-3des1.c	2016-12-23 17:47:36.430817752 +0100
@@ -44,7 +44,7 @@
  */
 struct ssh1_3des_ctx
 {
-	EVP_CIPHER_CTX	k1, k2, k3;
+	EVP_CIPHER_CTX	*k1, *k2, *k3;
 };
 
 const EVP_CIPHER * evp_ssh1_3des(void);
@@ -65,7 +65,7 @@ ssh1_3des_init(EVP_CIPHER_CTX *ctx, cons
 	if (key == NULL)
 		return 1;
 	if (enc == -1)
-		enc = ctx->encrypt;
+		enc = EVP_CIPHER_CTX_encrypting(ctx);
 	k1 = k2 = k3 = (u_char *) key;
 	k2 += 8;
 	if (EVP_CIPHER_CTX_key_length(ctx) >= 16+8) {
@@ -74,12 +74,19 @@ ssh1_3des_init(EVP_CIPHER_CTX *ctx, cons
 		else
 			k1 += 16;
 	}
-	EVP_CIPHER_CTX_init(&c->k1);
-	EVP_CIPHER_CTX_init(&c->k2);
-	EVP_CIPHER_CTX_init(&c->k3);
-	if (EVP_CipherInit(&c->k1, EVP_des_cbc(), k1, NULL, enc) == 0 ||
-	    EVP_CipherInit(&c->k2, EVP_des_cbc(), k2, NULL, !enc) == 0 ||
-	    EVP_CipherInit(&c->k3, EVP_des_cbc(), k3, NULL, enc) == 0) {
+	c->k1 = EVP_CIPHER_CTX_new();
+	c->k2 = EVP_CIPHER_CTX_new();
+	c->k3 = EVP_CIPHER_CTX_new();
+	if (c->k1 == NULL || c->k2 == NULL || c->k3 == NULL) {
+		EVP_CIPHER_CTX_free(c->k1);
+		EVP_CIPHER_CTX_free(c->k2);
+		EVP_CIPHER_CTX_free(c->k3);
+		free(c);
+		return 0;
+	}
+	if (EVP_CipherInit(c->k1, EVP_des_cbc(), k1, NULL, enc) == 0 ||
+	    EVP_CipherInit(c->k2, EVP_des_cbc(), k2, NULL, !enc) == 0 ||
+	    EVP_CipherInit(c->k3, EVP_des_cbc(), k3, NULL, enc) == 0) {
 		explicit_bzero(c, sizeof(*c));
 		free(c);
 		EVP_CIPHER_CTX_set_app_data(ctx, NULL);
@@ -95,9 +102,9 @@ ssh1_3des_cbc(EVP_CIPHER_CTX *ctx, u_cha
 
 	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL)
 		return 0;
-	if (EVP_Cipher(&c->k1, dest, (u_char *)src, len) == 0 ||
-	    EVP_Cipher(&c->k2, dest, dest, len) == 0 ||
-	    EVP_Cipher(&c->k3, dest, dest, len) == 0)
+	if (EVP_Cipher(c->k1, dest, (u_char *)src, len) == 0 ||
+	    EVP_Cipher(c->k2, dest, dest, len) == 0 ||
+	    EVP_Cipher(c->k3, dest, dest, len) == 0)
 		return 0;
 	return 1;
 }
@@ -108,9 +115,9 @@ ssh1_3des_cleanup(EVP_CIPHER_CTX *ctx)
 	struct ssh1_3des_ctx *c;
 
 	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) != NULL) {
-		EVP_CIPHER_CTX_cleanup(&c->k1);
-		EVP_CIPHER_CTX_cleanup(&c->k2);
-		EVP_CIPHER_CTX_cleanup(&c->k3);
+		EVP_CIPHER_CTX_free(c->k1);
+		EVP_CIPHER_CTX_free(c->k2);
+		EVP_CIPHER_CTX_free(c->k3);
 		explicit_bzero(c, sizeof(*c));
 		free(c);
 		EVP_CIPHER_CTX_set_app_data(ctx, NULL);
@@ -128,13 +135,13 @@ ssh1_3des_iv(EVP_CIPHER_CTX *evp, int do
 	if ((c = EVP_CIPHER_CTX_get_app_data(evp)) == NULL)
 		return SSH_ERR_INTERNAL_ERROR;
 	if (doset) {
-		memcpy(c->k1.iv, iv, 8);
-		memcpy(c->k2.iv, iv + 8, 8);
-		memcpy(c->k3.iv, iv + 16, 8);
+		memcpy(EVP_CIPHER_CTX_iv_noconst(c->k1), iv, 8);
+		memcpy(EVP_CIPHER_CTX_iv_noconst(c->k2), iv + 8, 8);
+		memcpy(EVP_CIPHER_CTX_iv_noconst(c->k3), iv + 16, 8);
 	} else {
-		memcpy(iv, c->k1.iv, 8);
-		memcpy(iv + 8, c->k2.iv, 8);
-		memcpy(iv + 16, c->k3.iv, 8);
+		memcpy(iv, EVP_CIPHER_CTX_iv(c->k1), 8);
+		memcpy(iv + 8, EVP_CIPHER_CTX_iv(c->k2), 8);
+		memcpy(iv + 16, EVP_CIPHER_CTX_iv(c->k3), 8);
 	}
 	return 0;
 }
@@ -142,17 +149,14 @@ ssh1_3des_iv(EVP_CIPHER_CTX *evp, int do
 const EVP_CIPHER *
 evp_ssh1_3des(void)
 {
-	static EVP_CIPHER ssh1_3des;
+	EVP_CIPHER *ssh1_3des;
 
-	memset(&ssh1_3des, 0, sizeof(ssh1_3des));
-	ssh1_3des.nid = NID_undef;
-	ssh1_3des.block_size = 8;
-	ssh1_3des.iv_len = 0;
-	ssh1_3des.key_len = 16;
-	ssh1_3des.init = ssh1_3des_init;
-	ssh1_3des.cleanup = ssh1_3des_cleanup;
-	ssh1_3des.do_cipher = ssh1_3des_cbc;
-	ssh1_3des.flags = EVP_CIPH_CBC_MODE | EVP_CIPH_VARIABLE_LENGTH;
-	return &ssh1_3des;
+	ssh1_3des = EVP_CIPHER_meth_new(NID_undef, 8, 16);
+	EVP_CIPHER_meth_set_iv_length(ssh1_3des, 0);
+	EVP_CIPHER_meth_set_init(ssh1_3des, ssh1_3des_init);
+	EVP_CIPHER_meth_set_cleanup(ssh1_3des, ssh1_3des_cleanup);
+	EVP_CIPHER_meth_set_do_cipher(ssh1_3des, ssh1_3des_cbc);
+	EVP_CIPHER_meth_set_flags(ssh1_3des, EVP_CIPH_CBC_MODE | EVP_CIPH_VARIABLE_LENGTH);
+	return ssh1_3des;
 }
 #endif /* WITH_SSH1 */
diff -up openssh-7.4p1/cipher-bf1.c.openssl openssh-7.4p1/cipher-bf1.c
--- openssh-7.4p1/cipher-bf1.c.openssl	2016-12-19 05:59:41.000000000 +0100
+++ openssh-7.4p1/cipher-bf1.c	2016-12-23 17:47:36.430817752 +0100
@@ -89,17 +89,28 @@ bf_ssh1_cipher(EVP_CIPHER_CTX *ctx, u_ch
 const EVP_CIPHER *
 evp_ssh1_bf(void)
 {
-	static EVP_CIPHER ssh1_bf;
+	EVP_CIPHER *ssh1_bf;
 
-	memcpy(&ssh1_bf, EVP_bf_cbc(), sizeof(EVP_CIPHER));
-	orig_bf = ssh1_bf.do_cipher;
-	ssh1_bf.nid = NID_undef;
+	orig_bf = EVP_CIPHER_meth_get_do_cipher(EVP_bf_cbc());
+	/* block_size, length, flags from openssl/crypto/engine/eng_cryptodev.c:638 */
+	ssh1_bf = EVP_CIPHER_meth_new(NID_undef, 8, 32);
+	EVP_CIPHER_meth_set_iv_length(ssh1_bf, 8);
+	EVP_CIPHER_meth_set_flags(ssh1_bf, EVP_CIPH_CBC_MODE);
 #ifdef SSH_OLD_EVP
-	ssh1_bf.init = bf_ssh1_init;
+	EVP_CIPHER_meth_set_init(ssh1_bf, ssh1_bf_init);
+#else
+	EVP_CIPHER_meth_set_init(ssh1_bf,
+	    EVP_CIPHER_meth_get_init(EVP_bf_cbc()));
 #endif
-	ssh1_bf.do_cipher = bf_ssh1_cipher;
-	ssh1_bf.key_len = 32;
-	return (&ssh1_bf);
+	/* copy methods and parameters from old EVP_BF_cbc()
+	 * meth_dup does not allow to change type and key_len */
+	EVP_CIPHER_meth_set_cleanup(ssh1_bf,
+	    EVP_CIPHER_meth_get_cleanup(EVP_bf_cbc()));
+	EVP_CIPHER_meth_set_ctrl(ssh1_bf,
+	    EVP_CIPHER_meth_get_ctrl(EVP_bf_cbc()));
+	/* ASN1 params??? */
+	EVP_CIPHER_meth_set_do_cipher(ssh1_bf, bf_ssh1_cipher);
+	return ssh1_bf;
 }
 #endif /* defined(WITH_OPENSSL) && !defined(OPENSSL_NO_BF) */
 
diff -up openssh-7.4p1/cipher.c.openssl openssh-7.4p1/cipher.c
--- openssh-7.4p1/cipher.c.openssl	2016-12-23 17:47:36.418817747 +0100
+++ openssh-7.4p1/cipher.c	2016-12-23 17:47:36.430817752 +0100
@@ -368,7 +368,7 @@ cipher_init(struct sshcipher_ctx **ccp,
 		ret = SSH_ERR_ALLOC_FAIL;
 		goto out;
 	}
-	if (EVP_CipherInit(cc->evp, type, NULL, (u_char *)iv,
+	if (EVP_CipherInit(cc->evp, type, (u_char *)key, (u_char *)iv,
 	    (do_encrypt == CIPHER_ENCRYPT)) == 0) {
 		ret = SSH_ERR_LIBCRYPTO_ERROR;
 		goto out;
@@ -386,10 +386,6 @@ cipher_init(struct sshcipher_ctx **ccp,
 			goto out;
 		}
 	}
-	if (EVP_CipherInit(cc->evp, NULL, (u_char *)key, NULL, -1) == 0) {
-		ret = SSH_ERR_LIBCRYPTO_ERROR;
-		goto out;
-	}
 
 	if (cipher->discard_len > 0) {
 		if ((junk = malloc(cipher->discard_len)) == NULL ||
@@ -621,7 +617,7 @@ cipher_get_keyiv(struct sshcipher_ctx *c
 			   len, iv))
 			       return SSH_ERR_LIBCRYPTO_ERROR;
 		} else
-			memcpy(iv, cc->evp->iv, len);
+			memcpy(iv, EVP_CIPHER_CTX_iv(cc->evp), len);
 		break;
 #endif
 #ifdef WITH_SSH1
@@ -667,7 +663,7 @@ cipher_set_keyiv(struct sshcipher_ctx *c
 			    EVP_CTRL_GCM_SET_IV_FIXED, -1, (void *)iv))
 				return SSH_ERR_LIBCRYPTO_ERROR;
 		} else
-			memcpy(cc->evp->iv, iv, evplen);
+			memcpy(EVP_CIPHER_CTX_iv_noconst(cc->evp), iv, evplen);
 		break;
 #endif
 #ifdef WITH_SSH1
@@ -681,8 +677,8 @@ cipher_set_keyiv(struct sshcipher_ctx *c
 }
 
 #ifdef WITH_OPENSSL
-#define EVP_X_STATE(evp)	(evp)->cipher_data
-#define EVP_X_STATE_LEN(evp)	(evp)->cipher->ctx_size
+#define EVP_X_STATE(evp)	EVP_CIPHER_CTX_get_cipher_data(evp)
+#define EVP_X_STATE_LEN(evp)	EVP_CIPHER_impl_ctx_size(EVP_CIPHER_CTX_cipher(evp))
 #endif
 
 int
diff -up openssh-7.4p1/ctr-cavstest.c.openssl openssh-7.4p1/ctr-cavstest.c
--- openssh-7.4p1/ctr-cavstest.c.openssl	2016-12-23 17:47:36.344817716 +0100
+++ openssh-7.4p1/ctr-cavstest.c	2016-12-23 17:47:36.430817752 +0100
@@ -144,7 +144,7 @@ int main (int argc, char *argv[])
                 usage();
         }
 
-	SSLeay_add_all_algorithms();
+	OpenSSL_add_all_algorithms();
 
 	c = cipher_by_name(algo);
 	if (c == NULL) {
 

diff -up openssh-7.4p1/entropy.c.openssl openssh-7.4p1/entropy.c
--- openssh-7.4p1/entropy.c.openssl	2016-12-23 17:47:36.419817747 +0100
+++ openssh-7.4p1/entropy.c	2016-12-23 17:47:36.431817752 +0100
@@ -218,7 +218,9 @@ seed_rng(void)
 		    "have %lx", (u_long)OPENSSL_VERSION_NUMBER, SSLeay());
 
 	/* clean the PRNG status when exiting the program */
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 	atexit(RAND_cleanup);
+#endif
 
 #ifndef OPENSSL_PRNG_ONLY
 	if (RAND_status() == 1) {
diff -up openssh-7.4p1/gss-genr.c.openssl openssh-7.4p1/gss-genr.c
--- openssh-7.4p1/gss-genr.c.openssl	2016-12-23 17:47:36.392817736 +0100
+++ openssh-7.4p1/gss-genr.c	2016-12-23 17:47:36.431817752 +0100
@@ -99,7 +99,7 @@ ssh_gssapi_kex_mechs(gss_OID_set gss_sup
 	u_char digest[EVP_MAX_MD_SIZE];
 	char deroid[2];
 	const EVP_MD *evp_md = EVP_md5();
-	EVP_MD_CTX md;
+	EVP_MD_CTX *md;
 	char *s, *cp, *p;
 
 	if (gss_enc2oid != NULL) {
@@ -113,6 +113,7 @@ ssh_gssapi_kex_mechs(gss_OID_set gss_sup
 
 	buffer_init(&buf);
 
+	md = EVP_MD_CTX_new();
 	oidpos = 0;
 	s = cp = xstrdup(kex);
 	for (i = 0; i < gss_supported->count; i++) {
@@ -122,12 +123,13 @@ ssh_gssapi_kex_mechs(gss_OID_set gss_sup
 			deroid[0] = SSH_GSS_OIDTYPE;
 			deroid[1] = gss_supported->elements[i].length;
 
-			EVP_DigestInit(&md, evp_md);
-			EVP_DigestUpdate(&md, deroid, 2);
-			EVP_DigestUpdate(&md,
+			EVP_MD_CTX_reset(md);
+			EVP_DigestInit(md, evp_md);
+			EVP_DigestUpdate(md, deroid, 2);
+			EVP_DigestUpdate(md,
 			    gss_supported->elements[i].elements,
 			    gss_supported->elements[i].length);
-			EVP_DigestFinal(&md, digest, NULL);
+			EVP_DigestFinal(md, digest, NULL);
 
 			encoded = xmalloc(EVP_MD_size(evp_md) * 2);
 			enclen = __b64_ntop(digest, EVP_MD_size(evp_md),
@@ -149,6 +151,7 @@ ssh_gssapi_kex_mechs(gss_OID_set gss_sup
 		}
 	}
 	free(s);
+	EVP_MD_CTX_free(md);
 	gss_enc2oid[oidpos].oid = NULL;
 	gss_enc2oid[oidpos].encoded = NULL;
 
diff -up openssh-7.4p1/includes.h.openssl openssh-7.4p1/includes.h
--- openssh-7.4p1/includes.h.openssl	2016-12-19 05:59:41.000000000 +0100
+++ openssh-7.4p1/includes.h	2016-12-23 17:47:36.431817752 +0100
@@ -163,6 +163,7 @@
 
 #ifdef WITH_OPENSSL
 #include <openssl/opensslv.h> /* For OPENSSL_VERSION_NUMBER */
+#include "libcrypto-compat.h"
 #endif
 
 #include "defines.h"



diff -up openssh-7.4p1/kexgssc.c.openssl openssh-7.4p1/kexgssc.c
--- openssh-7.4p1/kexgssc.c.openssl	2016-12-23 17:47:36.349817718 +0100
+++ openssh-7.4p1/kexgssc.c	2016-12-23 17:47:36.432817753 +0100
@@ -58,6 +58,7 @@ kexgss_client(struct ssh *ssh) {
 	BIGNUM *shared_secret = NULL;
 	BIGNUM *p = NULL;
 	BIGNUM *g = NULL;	
+	const BIGNUM *pub_key, *p1, *g1;
 	u_char *kbuf;
 	u_char *serverhostkey = NULL;
 	u_char *empty = "";
@@ -121,6 +122,7 @@ kexgss_client(struct ssh *ssh) {
 	
 	/* Step 1 - e is dh->pub_key */
 	dh_gen_key(dh, ssh->kex->we_need * 8);
+	DH_get0_key(dh, &pub_key, NULL);
 
 	/* This is f, we initialise it now to make life easier */
 	dh_server_pub = BN_new();
@@ -168,7 +170,7 @@ kexgss_client(struct ssh *ssh) {
 				packet_start(SSH2_MSG_KEXGSS_INIT);
 				packet_put_string(send_tok.value,
 				    send_tok.length);
-				packet_put_bignum2(dh->pub_key);
+				packet_put_bignum2((BIGNUM *)pub_key);
 				first = 0;
 			} else {
 				packet_start(SSH2_MSG_KEXGSS_CONTINUE);
@@ -275,13 +277,14 @@ kexgss_client(struct ssh *ssh) {
 		    buffer_ptr(ssh->kex->my), buffer_len(ssh->kex->my),
 		    buffer_ptr(ssh->kex->peer), buffer_len(ssh->kex->peer),
 		    (serverhostkey ? serverhostkey : empty), slen,
-		    dh->pub_key,	/* e */
+		    pub_key,		/* e */
 		    dh_server_pub,	/* f */
 		    shared_secret,	/* K */
 		    hash, &hashlen
 		);
 		break;
 	case KEX_GSS_GEX_SHA1:
+		DH_get0_pqg(dh, &p1, NULL, &g1);
 		kexgex_hash(
 		    ssh->kex->hash_alg,
 		    ssh->kex->client_version_string,
@@ -290,8 +293,8 @@ kexgss_client(struct ssh *ssh) {
 		    buffer_ptr(ssh->kex->peer), buffer_len(ssh->kex->peer),
 		    (serverhostkey ? serverhostkey : empty), slen,
  		    min, nbits, max,
-		    dh->p, dh->g,
-		    dh->pub_key,
+		    p1, g1,
+		    pub_key,
 		    dh_server_pub,
 		    shared_secret,
 		    hash, &hashlen
diff -up openssh-7.4p1/kexgsss.c.openssl openssh-7.4p1/kexgsss.c
--- openssh-7.4p1/kexgsss.c.openssl	2016-12-23 17:47:36.349817718 +0100
+++ openssh-7.4p1/kexgsss.c	2016-12-23 17:47:36.432817753 +0100
@@ -77,6 +77,7 @@ kexgss_server(struct ssh *ssh)
 	char *mechs;
 	u_char hash[SSH_DIGEST_MAX_LENGTH];
 	size_t hashlen;
+	const BIGNUM *p, *g, *pub_key;
 
 	/* Initialise GSSAPI */
 
@@ -122,9 +123,10 @@ kexgss_server(struct ssh *ssh)
 		if (dh == NULL)
 			packet_disconnect("Protocol error: no matching group found");
 
+		DH_get0_pqg(dh, &p, NULL, &g);
 		packet_start(SSH2_MSG_KEXGSS_GROUP);
-		packet_put_bignum2(dh->p);
-		packet_put_bignum2(dh->g);
+		packet_put_bignum2((BIGNUM *)p);
+		packet_put_bignum2((BIGNUM *)g);
 		packet_send();
 
 		packet_write_wait();
@@ -216,6 +218,7 @@ kexgss_server(struct ssh *ssh)
 	memset(kbuf, 0, klen);
 	free(kbuf);
 
+	DH_get0_key(dh, &pub_key, NULL);
 	hashlen = sizeof(hash);
 	switch (ssh->kex->kex_type) {
 	case KEX_GSS_GRP1_SHA1:
@@ -225,7 +228,7 @@ kexgss_server(struct ssh *ssh)
 		    buffer_ptr(ssh->kex->peer), buffer_len(ssh->kex->peer),
 		    buffer_ptr(ssh->kex->my), buffer_len(ssh->kex->my),
 		    NULL, 0, /* Change this if we start sending host keys */
-		    dh_client_pub, dh->pub_key, shared_secret,
+		    dh_client_pub, pub_key, shared_secret,
 		    hash, &hashlen
 		);
 		break;
@@ -237,9 +240,9 @@ kexgss_server(struct ssh *ssh)
 		    buffer_ptr(ssh->kex->my), buffer_len(ssh->kex->my),
 		    NULL, 0,
 		    cmin, nbits, cmax,
-		    dh->p, dh->g,
+		    p, g,
 		    dh_client_pub,
-		    dh->pub_key,
+		    pub_key,
 		    shared_secret,
 		    hash, &hashlen
 		);
@@ -263,7 +266,7 @@ kexgss_server(struct ssh *ssh)
 		fatal("Couldn't get MIC");
 
 	packet_start(SSH2_MSG_KEXGSS_COMPLETE);
-	packet_put_bignum2(dh->pub_key);
+	packet_put_bignum2((BIGNUM *)pub_key);
 	packet_put_string(msg_tok.value,msg_tok.length);
 
 	if (send_tok.length != 0) {
diff -up openssh-7.4p1/libcrypto-compat.c.openssl openssh-7.4p1/libcrypto-compat.c
--- openssh-7.4p1/libcrypto-compat.c.openssl	2016-12-23 17:47:36.432817753 +0100
+++ openssh-7.4p1/libcrypto-compat.c	2016-12-23 17:47:36.432817753 +0100
@@ -0,0 +1,546 @@
+/*
+ * Copyright 2016 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://www.openssl.org/source/license.html
+ */
+
+#include "includes.h"
+
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
+
+#include <string.h>
+#include <openssl/engine.h>
+
+static void *OPENSSL_zalloc(size_t num)
+{
+    void *ret = OPENSSL_malloc(num);
+
+    if (ret != NULL)
+        memset(ret, 0, num);
+    return ret;
+}
+
+int RSA_set0_key(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d)
+{
+    /* If the fields n and e in r are NULL, the corresponding input
+     * parameters MUST be non-NULL for n and e.  d may be
+     * left NULL (in case only the public key is used).
+     */
+    if ((r->n == NULL && n == NULL)
+        || (r->e == NULL && e == NULL))
+        return 0;
+
+    if (n != NULL) {
+        BN_free(r->n);
+        r->n = n;
+    }
+    if (e != NULL) {
+        BN_free(r->e);
+        r->e = e;
+    }
+    if (d != NULL) {
+        BN_free(r->d);
+        r->d = d;
+    }
+
+    return 1;
+}
+
+int RSA_set0_factors(RSA *r, BIGNUM *p, BIGNUM *q)
+{
+    /* If the fields p and q in r are NULL, the corresponding input
+     * parameters MUST be non-NULL.
+     */
+    if ((r->p == NULL && p == NULL)
+        || (r->q == NULL && q == NULL))
+        return 0;
+
+    if (p != NULL) {
+        BN_free(r->p);
+        r->p = p;
+    }
+    if (q != NULL) {
+        BN_free(r->q);
+        r->q = q;
+    }
+
+    return 1;
+}
+
+int RSA_set0_crt_params(RSA *r, BIGNUM *dmp1, BIGNUM *dmq1, BIGNUM *iqmp)
+{
+    /* If the fields dmp1, dmq1 and iqmp in r are NULL, the corresponding input
+     * parameters MUST be non-NULL.
+     */
+    if ((r->dmp1 == NULL && dmp1 == NULL)
+        || (r->dmq1 == NULL && dmq1 == NULL)
+        || (r->iqmp == NULL && iqmp == NULL))
+        return 0;
+
+    if (dmp1 != NULL) {
+        BN_free(r->dmp1);
+        r->dmp1 = dmp1;
+    }
+    if (dmq1 != NULL) {
+        BN_free(r->dmq1);
+        r->dmq1 = dmq1;
+    }
+    if (iqmp != NULL) {
+        BN_free(r->iqmp);
+        r->iqmp = iqmp;
+    }
+
+    return 1;
+}
+
+void RSA_get0_key(const RSA *r,
+                  const BIGNUM **n, const BIGNUM **e, const BIGNUM **d)
+{
+    if (n != NULL)
+        *n = r->n;
+    if (e != NULL)
+        *e = r->e;
+    if (d != NULL)
+        *d = r->d;
+}
+
+void RSA_get0_factors(const RSA *r, const BIGNUM **p, const BIGNUM **q)
+{
+    if (p != NULL)
+        *p = r->p;
+    if (q != NULL)
+        *q = r->q;
+}
+
+void RSA_get0_crt_params(const RSA *r,
+                         const BIGNUM **dmp1, const BIGNUM **dmq1,
+                         const BIGNUM **iqmp)
+{
+    if (dmp1 != NULL)
+        *dmp1 = r->dmp1;
+    if (dmq1 != NULL)
+        *dmq1 = r->dmq1;
+    if (iqmp != NULL)
+        *iqmp = r->iqmp;
+}
+
+void DSA_get0_pqg(const DSA *d,
+                  const BIGNUM **p, const BIGNUM **q, const BIGNUM **g)
+{
+    if (p != NULL)
+        *p = d->p;
+    if (q != NULL)
+        *q = d->q;
+    if (g != NULL)
+        *g = d->g;
+}
+
+int DSA_set0_pqg(DSA *d, BIGNUM *p, BIGNUM *q, BIGNUM *g)
+{
+    /* If the fields p, q and g in d are NULL, the corresponding input
+     * parameters MUST be non-NULL.
+     */
+    if ((d->p == NULL && p == NULL)
+        || (d->q == NULL && q == NULL)
+        || (d->g == NULL && g == NULL))
+        return 0;
+
+    if (p != NULL) {
+        BN_free(d->p);
+        d->p = p;
+    }
+    if (q != NULL) {
+        BN_free(d->q);
+        d->q = q;
+    }
+    if (g != NULL) {
+        BN_free(d->g);
+        d->g = g;
+    }
+
+    return 1;
+}
+
+void DSA_get0_key(const DSA *d,
+                  const BIGNUM **pub_key, const BIGNUM **priv_key)
+{
+    if (pub_key != NULL)
+        *pub_key = d->pub_key;
+    if (priv_key != NULL)
+        *priv_key = d->priv_key;
+}
+
+int DSA_set0_key(DSA *d, BIGNUM *pub_key, BIGNUM *priv_key)
+{
+    /* If the field pub_key in d is NULL, the corresponding input
+     * parameters MUST be non-NULL.  The priv_key field may
+     * be left NULL.
+     */
+    if (d->pub_key == NULL && pub_key == NULL)
+        return 0;
+
+    if (pub_key != NULL) {
+        BN_free(d->pub_key);
+        d->pub_key = pub_key;
+    }
+    if (priv_key != NULL) {
+        BN_free(d->priv_key);
+        d->priv_key = priv_key;
+    }
+
+    return 1;
+}
+
+void DSA_SIG_get0(const DSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps)
+{
+    if (pr != NULL)
+        *pr = sig->r;
+    if (ps != NULL)
+        *ps = sig->s;
+}
+
+int DSA_SIG_set0(DSA_SIG *sig, BIGNUM *r, BIGNUM *s)
+{
+    if (r == NULL || s == NULL)
+        return 0;
+    BN_clear_free(sig->r);
+    BN_clear_free(sig->s);
+    sig->r = r;
+    sig->s = s;
+    return 1;
+}
+
+void ECDSA_SIG_get0(const ECDSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps)
+{
+    if (pr != NULL)
+        *pr = sig->r;
+    if (ps != NULL)
+        *ps = sig->s;
+}
+
+int ECDSA_SIG_set0(ECDSA_SIG *sig, BIGNUM *r, BIGNUM *s)
+{
+    if (r == NULL || s == NULL)
+        return 0;
+    BN_clear_free(sig->r);
+    BN_clear_free(sig->s);
+    sig->r = r;
+    sig->s = s;
+    return 1;
+}
+
+void DH_get0_pqg(const DH *dh,
+                 const BIGNUM **p, const BIGNUM **q, const BIGNUM **g)
+{
+    if (p != NULL)
+        *p = dh->p;
+    if (q != NULL)
+        *q = dh->q;
+    if (g != NULL)
+        *g = dh->g;
+}
+
+int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g)
+{
+    /* If the fields p and g in d are NULL, the corresponding input
+     * parameters MUST be non-NULL.  q may remain NULL.
+     */
+    if ((dh->p == NULL && p == NULL)
+        || (dh->g == NULL && g == NULL))
+        return 0;
+
+    if (p != NULL) {
+        BN_free(dh->p);
+        dh->p = p;
+    }
+    if (q != NULL) {
+        BN_free(dh->q);
+        dh->q = q;
+    }
+    if (g != NULL) {
+        BN_free(dh->g);
+        dh->g = g;
+    }
+
+    if (q != NULL) {
+        dh->length = BN_num_bits(q);
+    }
+
+    return 1;
+}
+
+void DH_get0_key(const DH *dh, const BIGNUM **pub_key, const BIGNUM **priv_key)
+{
+    if (pub_key != NULL)
+        *pub_key = dh->pub_key;
+    if (priv_key != NULL)
+        *priv_key = dh->priv_key;
+}
+
+int DH_set0_key(DH *dh, BIGNUM *pub_key, BIGNUM *priv_key)
+{
+    /* If the field pub_key in dh is NULL, the corresponding input
+     * parameters MUST be non-NULL.  The priv_key field may
+     * be left NULL.
+     */
+    if (dh->pub_key == NULL && pub_key == NULL)
+        return 0;
+
+    if (pub_key != NULL) {
+        BN_free(dh->pub_key);
+        dh->pub_key = pub_key;
+    }
+    if (priv_key != NULL) {
+        BN_free(dh->priv_key);
+        dh->priv_key = priv_key;
+    }
+
+    return 1;
+}
+
+int DH_set_length(DH *dh, long length)
+{
+    dh->length = length;
+    return 1;
+}
+
+const unsigned char *EVP_CIPHER_CTX_iv(const EVP_CIPHER_CTX *ctx)
+{
+    return ctx->iv;
+}
+
+unsigned char *EVP_CIPHER_CTX_iv_noconst(EVP_CIPHER_CTX *ctx)
+{
+    return ctx->iv;
+}
+
+EVP_MD_CTX *EVP_MD_CTX_new(void)
+{
+    return OPENSSL_zalloc(sizeof(EVP_MD_CTX));
+}
+
+static void OPENSSL_clear_free(void *str, size_t num)
+{
+    if (str == NULL)
+        return;
+    if (num)
+        OPENSSL_cleanse(str, num);
+    OPENSSL_free(str);
+}
+
+/* This call frees resources associated with the context */
+int EVP_MD_CTX_reset(EVP_MD_CTX *ctx)
+{
+    if (ctx == NULL)
+        return 1;
+
+    /*
+     * Don't assume ctx->md_data was cleaned in EVP_Digest_Final, because
+     * sometimes only copies of the context are ever finalised.
+     */
+    if (ctx->digest && ctx->digest->cleanup
+        && !EVP_MD_CTX_test_flags(ctx, EVP_MD_CTX_FLAG_CLEANED))
+        ctx->digest->cleanup(ctx);
+    if (ctx->digest && ctx->digest->ctx_size && ctx->md_data
+        && !EVP_MD_CTX_test_flags(ctx, EVP_MD_CTX_FLAG_REUSE)) {
+        OPENSSL_clear_free(ctx->md_data, ctx->digest->ctx_size);
+    }
+    EVP_PKEY_CTX_free(ctx->pctx);
+#ifndef OPENSSL_NO_ENGINE
+    ENGINE_finish(ctx->engine);
+#endif
+    OPENSSL_cleanse(ctx, sizeof(*ctx));
+
+    return 1;
+}
+
+void EVP_MD_CTX_free(EVP_MD_CTX *ctx)
+{
+    EVP_MD_CTX_reset(ctx);
+    OPENSSL_free(ctx);
+}
+
+RSA_METHOD *RSA_meth_dup(const RSA_METHOD *meth)
+{
+    RSA_METHOD *ret;
+
+    ret = OPENSSL_malloc(sizeof(RSA_METHOD));
+
+    if (ret != NULL) {
+        memcpy(ret, meth, sizeof(*meth));
+        ret->name = OPENSSL_strdup(meth->name);
+        if (ret->name == NULL) {
+            OPENSSL_free(ret);
+            return NULL;
+        }
+    }
+
+    return ret;
+}
+
+int RSA_meth_set1_name(RSA_METHOD *meth, const char *name)
+{
+    char *tmpname;
+
+    tmpname = OPENSSL_strdup(name);
+    if (tmpname == NULL) {
+        return 0;
+    }
+
+    OPENSSL_free((char *)meth->name);
+    meth->name = tmpname;
+
+    return 1;
+}
+
+int RSA_meth_set_priv_enc(RSA_METHOD *meth,
+                          int (*priv_enc) (int flen, const unsigned char *from,
+                                           unsigned char *to, RSA *rsa,
+                                           int padding))
+{
+    meth->rsa_priv_enc = priv_enc;
+    return 1;
+}
+
+int RSA_meth_set_priv_dec(RSA_METHOD *meth,
+                          int (*priv_dec) (int flen, const unsigned char *from,
+                                           unsigned char *to, RSA *rsa,
+                                           int padding))
+{
+    meth->rsa_priv_dec = priv_dec;
+    return 1;
+}
+
+int RSA_meth_set_finish(RSA_METHOD *meth, int (*finish) (RSA *rsa))
+{
+    meth->finish = finish;
+    return 1;
+}
+
+void RSA_meth_free(RSA_METHOD *meth)
+{
+    if (meth != NULL) {
+        OPENSSL_free((char *)meth->name);
+        OPENSSL_free(meth);
+    }
+}
+
+int RSA_bits(const RSA *r)
+{
+    return (BN_num_bits(r->n));
+}
+
+int DSA_bits(const DSA *dsa)
+{
+    return BN_num_bits(dsa->p);
+}
+
+RSA *EVP_PKEY_get0_RSA(EVP_PKEY *pkey)
+{
+    if (pkey->type != EVP_PKEY_RSA) {
+        return NULL;
+    }
+    return pkey->pkey.rsa;
+}
+
+EVP_CIPHER *EVP_CIPHER_meth_new(int cipher_type, int block_size, int key_len)
+{
+    EVP_CIPHER *cipher = OPENSSL_zalloc(sizeof(EVP_CIPHER));
+
+    if (cipher != NULL) {
+        cipher->nid = cipher_type;
+        cipher->block_size = block_size;
+        cipher->key_len = key_len;
+    }
+    return cipher;
+}
+
+void EVP_CIPHER_meth_free(EVP_CIPHER *cipher)
+{
+    OPENSSL_free(cipher);
+}
+
+int EVP_CIPHER_meth_set_iv_length(EVP_CIPHER *cipher, int iv_len)
+{
+    cipher->iv_len = iv_len;
+    return 1;
+}
+
+int EVP_CIPHER_meth_set_flags(EVP_CIPHER *cipher, unsigned long flags)
+{
+    cipher->flags = flags;
+    return 1;
+}
+
+int EVP_CIPHER_meth_set_init(EVP_CIPHER *cipher,
+                             int (*init) (EVP_CIPHER_CTX *ctx,
+                                          const unsigned char *key,
+                                          const unsigned char *iv,
+                                          int enc))
+{
+    cipher->init = init;
+    return 1;
+}
+
+int EVP_CIPHER_meth_set_do_cipher(EVP_CIPHER *cipher,
+                                  int (*do_cipher) (EVP_CIPHER_CTX *ctx,
+                                                    unsigned char *out,
+                                                    const unsigned char *in,
+                                                    size_t inl))
+{
+    cipher->do_cipher = do_cipher;
+    return 1;
+}
+
+int EVP_CIPHER_meth_set_cleanup(EVP_CIPHER *cipher,
+                                int (*cleanup) (EVP_CIPHER_CTX *))
+{
+    cipher->cleanup = cleanup;
+    return 1;
+}
+
+int EVP_CIPHER_meth_set_ctrl(EVP_CIPHER *cipher,
+                             int (*ctrl) (EVP_CIPHER_CTX *, int type,
+                                          int arg, void *ptr))
+{
+    cipher->ctrl = ctrl;
+    return 1;
+}
+
+int (*EVP_CIPHER_meth_get_init(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *ctx,
+                                                          const unsigned char *key,
+                                                          const unsigned char *iv,
+                                                          int enc)
+{
+    return cipher->init;
+}
+
+int (*EVP_CIPHER_meth_get_do_cipher(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *ctx,
+                                                               unsigned char *out,
+                                                               const unsigned char *in,
+                                                               size_t inl)
+{
+    return cipher->do_cipher;
+}
+
+int (*EVP_CIPHER_meth_get_cleanup(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *)
+{
+    return cipher->cleanup;
+}
+
+int (*EVP_CIPHER_meth_get_ctrl(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *,
+                                                          int type, int arg,
+                                                          void *ptr)
+{
+    return cipher->ctrl;
+}
+
+int EVP_CIPHER_CTX_encrypting(const EVP_CIPHER_CTX *ctx)
+{
+    return ctx->encrypt;
+}
+
+#endif /* OPENSSL_VERSION_NUMBER */
diff -up openssh-7.4p1/libcrypto-compat.h.openssl openssh-7.4p1/libcrypto-compat.h
--- openssh-7.4p1/libcrypto-compat.h.openssl	2016-12-23 17:47:36.432817753 +0100
+++ openssh-7.4p1/libcrypto-compat.h	2016-12-23 17:47:36.432817753 +0100
@@ -0,0 +1,98 @@
+#ifndef LIBCRYPTO_COMPAT_H
+#define LIBCRYPTO_COMPAT_H
+
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
+
+#include <openssl/rsa.h>
+#include <openssl/dsa.h>
+#include <openssl/ecdsa.h>
+#include <openssl/dh.h>
+#include <openssl/evp.h>
+
+int RSA_set0_key(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d);
+int RSA_set0_factors(RSA *r, BIGNUM *p, BIGNUM *q);
+int RSA_set0_crt_params(RSA *r, BIGNUM *dmp1, BIGNUM *dmq1, BIGNUM *iqmp);
+void RSA_get0_key(const RSA *r, const BIGNUM **n, const BIGNUM **e, const BIGNUM **d);
+void RSA_get0_factors(const RSA *r, const BIGNUM **p, const BIGNUM **q);
+void RSA_get0_crt_params(const RSA *r, const BIGNUM **dmp1, const BIGNUM **dmq1, const BIGNUM **iqmp);
+
+void DSA_get0_pqg(const DSA *d, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g);
+int DSA_set0_pqg(DSA *d, BIGNUM *p, BIGNUM *q, BIGNUM *g);
+void DSA_get0_key(const DSA *d, const BIGNUM **pub_key, const BIGNUM **priv_key);
+int DSA_set0_key(DSA *d, BIGNUM *pub_key, BIGNUM *priv_key);
+
+void DSA_SIG_get0(const DSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps);
+int DSA_SIG_set0(DSA_SIG *sig, BIGNUM *r, BIGNUM *s);
+
+void ECDSA_SIG_get0(const ECDSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps);
+int ECDSA_SIG_set0(ECDSA_SIG *sig, BIGNUM *r, BIGNUM *s);
+
+void DH_get0_pqg(const DH *dh, const BIGNUM **p, const BIGNUM **q, const BIGNUM **g);
+int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g);
+void DH_get0_key(const DH *dh, const BIGNUM **pub_key, const BIGNUM **priv_key);
+int DH_set0_key(DH *dh, BIGNUM *pub_key, BIGNUM *priv_key);
+int DH_set_length(DH *dh, long length);
+
+const unsigned char *EVP_CIPHER_CTX_iv(const EVP_CIPHER_CTX *ctx);
+unsigned char *EVP_CIPHER_CTX_iv_noconst(EVP_CIPHER_CTX *ctx);
+int EVP_MD_CTX_reset(EVP_MD_CTX *ctx);
+EVP_MD_CTX *EVP_MD_CTX_new(void);
+void EVP_MD_CTX_free(EVP_MD_CTX *ctx);
+#define EVP_CIPHER_impl_ctx_size(e) e->ctx_size
+#define EVP_CIPHER_CTX_get_cipher_data(ctx) ctx->cipher_data
+
+RSA_METHOD *RSA_meth_dup(const RSA_METHOD *meth);
+int RSA_meth_set1_name(RSA_METHOD *meth, const char *name);
+#define RSA_meth_get_finish(meth) meth->finish
+int RSA_meth_set_priv_enc(RSA_METHOD *meth, int (*priv_enc) (int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding));
+int RSA_meth_set_priv_dec(RSA_METHOD *meth, int (*priv_dec) (int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding));
+int RSA_meth_set_finish(RSA_METHOD *meth, int (*finish) (RSA *rsa));
+void RSA_meth_free(RSA_METHOD *meth);
+
+int RSA_bits(const RSA *r);
+int DSA_bits(const DSA *d);
+
+RSA *EVP_PKEY_get0_RSA(EVP_PKEY *pkey);
+
+EVP_CIPHER *EVP_CIPHER_meth_new(int cipher_type, int block_size, int key_len);
+void EVP_CIPHER_meth_free(EVP_CIPHER *cipher);
+
+int EVP_CIPHER_meth_set_iv_length(EVP_CIPHER *cipher, int iv_len);
+int EVP_CIPHER_meth_set_flags(EVP_CIPHER *cipher, unsigned long flags);
+int EVP_CIPHER_meth_set_init(EVP_CIPHER *cipher,
+                             int (*init) (EVP_CIPHER_CTX *ctx,
+                                          const unsigned char *key,
+                                          const unsigned char *iv,
+                                          int enc));
+int EVP_CIPHER_meth_set_do_cipher(EVP_CIPHER *cipher,
+                                  int (*do_cipher) (EVP_CIPHER_CTX *ctx,
+                                                    unsigned char *out,
+                                                    const unsigned char *in,
+                                                    size_t inl));
+int EVP_CIPHER_meth_set_cleanup(EVP_CIPHER *cipher,
+                                int (*cleanup) (EVP_CIPHER_CTX *));
+int EVP_CIPHER_meth_set_ctrl(EVP_CIPHER *cipher,
+                             int (*ctrl) (EVP_CIPHER_CTX *, int type,
+                                          int arg, void *ptr));
+
+int (*EVP_CIPHER_meth_get_init(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *ctx,
+                                                          const unsigned char *key,
+                                                          const unsigned char *iv,
+                                                          int enc);
+int (*EVP_CIPHER_meth_get_do_cipher(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *ctx,
+                                                               unsigned char *out,
+                                                               const unsigned char *in,
+                                                               size_t inl);
+int (*EVP_CIPHER_meth_get_cleanup(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *);
+int (*EVP_CIPHER_meth_get_ctrl(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *,
+                                                          int type, int arg,
+                                                          void *ptr);
+
+#define EVP_CIPHER_CTX_reset(c)      EVP_CIPHER_CTX_init(c)
+
+int EVP_CIPHER_CTX_encrypting(const EVP_CIPHER_CTX *ctx);
+
+#endif /* OPENSSL_VERSION_NUMBER */
+
+#endif /* LIBCRYPTO_COMPAT_H */
+
diff -up openssh-7.4p1/Makefile.in.openssl openssh-7.4p1/Makefile.in
--- openssh-7.4p1/Makefile.in.openssl	2016-12-23 17:47:36.420817748 +0100
+++ openssh-7.4p1/Makefile.in	2016-12-23 17:47:36.432817753 +0100
@@ -100,7 +100,7 @@ LIBSSH_OBJS=${LIBOPENSSH_OBJS} \
 	kex.o kexdh.o kexgex.o kexecdh.o kexc25519.o \
 	kexdhc.o kexgexc.o kexecdhc.o kexc25519c.o \
 	kexdhs.o kexgexs.o kexecdhs.o kexc25519s.o \
-	platform-pledge.o platform-tracing.o auditstub.o
+	platform-pledge.o platform-tracing.o auditstub.o libcrypto-compat.o
 
 SSHOBJS= ssh.o readconf.o clientloop.o sshtty.o \
 	sshconnect.o sshconnect1.o sshconnect2.o mux.o




diff -up openssh-7.4p1/openbsd-compat/openssl-compat.c.openssl openssh-7.4p1/openbsd-compat/openssl-compat.c
--- openssh-7.4p1/openbsd-compat/openssl-compat.c.openssl	2016-12-19 05:59:41.000000000 +0100
+++ openssh-7.4p1/openbsd-compat/openssl-compat.c	2016-12-23 17:47:36.433817753 +0100
@@ -70,12 +70,19 @@ ssh_compatible_openssl(long headerver, l
 void
 ssh_OpenSSL_add_all_algorithms(void)
 {
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 	OpenSSL_add_all_algorithms();
 
 	/* Enable use of crypto hardware */
 	ENGINE_load_builtin_engines();
+#if OPENSSL_VERSION_NUMBER < 0x10001000L
 	ENGINE_register_all_complete();
+#endif
 	OPENSSL_config(NULL);
+#else
+	OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_DIGESTS |
+	    OPENSSL_INIT_ADD_ALL_DIGESTS | OPENSSL_INIT_LOAD_CONFIG, NULL);
+#endif
 }
 #endif
 
diff -up openssh-7.4p1/pam_ssh_agent_auth-0.10.3/configure.ac.openssl openssh-7.4p1/pam_ssh_agent_auth-0.10.3/configure.ac
--- openssh-7.4p1/pam_ssh_agent_auth-0.10.3/configure.ac.openssl	2014-03-31 19:35:17.000000000 +0200
+++ openssh-7.4p1/pam_ssh_agent_auth-0.10.3/configure.ac	2016-12-23 17:47:36.433817753 +0100
@@ -1829,6 +1829,7 @@ AC_RUN_IFELSE(
 	[AC_LANG_SOURCE([[
 #include <string.h>
 #include <openssl/opensslv.h>
+#include <openssl/crypto.h>
 int main(void) { exit(SSLeay() == OPENSSL_VERSION_NUMBER ? 0 : 1); }
 	]])],
 	[
diff -up openssh-7.4p1/regress/unittests/sshkey/test_file.c.openssl openssh-7.4p1/regress/unittests/sshkey/test_file.c
--- openssh-7.4p1/regress/unittests/sshkey/test_file.c.openssl	2016-12-19 05:59:41.000000000 +0100
+++ openssh-7.4p1/regress/unittests/sshkey/test_file.c	2016-12-23 17:47:36.433817753 +0100
@@ -46,6 +46,7 @@ sshkey_file_tests(void)
 	struct sshbuf *buf, *pw;
 	BIGNUM *a, *b, *c;
 	char *cp;
+	const BIGNUM *n, *p, *q, *g, *pub_key, *priv_key;
 
 	TEST_START("load passphrase");
 	pw = load_text_file("pw");
@@ -58,7 +59,8 @@ sshkey_file_tests(void)
 	sshbuf_free(buf);
 	ASSERT_PTR_NE(k1, NULL);
 	a = load_bignum("rsa1_1.param.n");
-	ASSERT_BIGNUM_EQ(k1->rsa->n, a);
+	RSA_get0_key(k1->rsa, &n, NULL, NULL);
+	ASSERT_BIGNUM_EQ(n, a);
 	BN_free(a);
 	TEST_DONE();
 
@@ -109,9 +111,11 @@ sshkey_file_tests(void)
 	a = load_bignum("rsa_1.param.n");
 	b = load_bignum("rsa_1.param.p");
 	c = load_bignum("rsa_1.param.q");
-	ASSERT_BIGNUM_EQ(k1->rsa->n, a);
-	ASSERT_BIGNUM_EQ(k1->rsa->p, b);
-	ASSERT_BIGNUM_EQ(k1->rsa->q, c);
+	RSA_get0_key(k1->rsa, &n, NULL, NULL);
+	RSA_get0_factors(k1->rsa, &p, &q);
+	ASSERT_BIGNUM_EQ(n, a);
+	ASSERT_BIGNUM_EQ(p, b);
+	ASSERT_BIGNUM_EQ(q, c);
 	BN_free(a);
 	BN_free(b);
 	BN_free(c);
@@ -200,9 +204,11 @@ sshkey_file_tests(void)
 	a = load_bignum("dsa_1.param.g");
 	b = load_bignum("dsa_1.param.priv");
 	c = load_bignum("dsa_1.param.pub");
-	ASSERT_BIGNUM_EQ(k1->dsa->g, a);
-	ASSERT_BIGNUM_EQ(k1->dsa->priv_key, b);
-	ASSERT_BIGNUM_EQ(k1->dsa->pub_key, c);
+	DSA_get0_pqg(k1->dsa, NULL, NULL, &g);
+	DSA_get0_key(k1->dsa, &pub_key, &priv_key);
+	ASSERT_BIGNUM_EQ(g, a);
+	ASSERT_BIGNUM_EQ(priv_key, b);
+	ASSERT_BIGNUM_EQ(pub_key, c);
 	BN_free(a);
 	BN_free(b);
 	BN_free(c);
diff -up openssh-7.4p1/regress/unittests/sshkey/test_sshkey.c.openssl openssh-7.4p1/regress/unittests/sshkey/test_sshkey.c
--- openssh-7.4p1/regress/unittests/sshkey/test_sshkey.c.openssl	2016-12-19 05:59:41.000000000 +0100
+++ openssh-7.4p1/regress/unittests/sshkey/test_sshkey.c	2016-12-23 17:47:36.433817753 +0100
@@ -197,9 +197,6 @@ sshkey_tests(void)
 	k1 = sshkey_new(KEY_RSA1);
 	ASSERT_PTR_NE(k1, NULL);
 	ASSERT_PTR_NE(k1->rsa, NULL);
-	ASSERT_PTR_NE(k1->rsa->n, NULL);
-	ASSERT_PTR_NE(k1->rsa->e, NULL);
-	ASSERT_PTR_EQ(k1->rsa->p, NULL);
 	sshkey_free(k1);
 	TEST_DONE();
 
@@ -207,9 +204,6 @@ sshkey_tests(void)
 	k1 = sshkey_new(KEY_RSA);
 	ASSERT_PTR_NE(k1, NULL);
 	ASSERT_PTR_NE(k1->rsa, NULL);
-	ASSERT_PTR_NE(k1->rsa->n, NULL);
-	ASSERT_PTR_NE(k1->rsa->e, NULL);
-	ASSERT_PTR_EQ(k1->rsa->p, NULL);
 	sshkey_free(k1);
 	TEST_DONE();
 
@@ -217,8 +211,6 @@ sshkey_tests(void)
 	k1 = sshkey_new(KEY_DSA);
 	ASSERT_PTR_NE(k1, NULL);
 	ASSERT_PTR_NE(k1->dsa, NULL);
-	ASSERT_PTR_NE(k1->dsa->g, NULL);
-	ASSERT_PTR_EQ(k1->dsa->priv_key, NULL);
 	sshkey_free(k1);
 	TEST_DONE();
 
@@ -244,9 +236,6 @@ sshkey_tests(void)
 	k1 = sshkey_new_private(KEY_RSA);
 	ASSERT_PTR_NE(k1, NULL);
 	ASSERT_PTR_NE(k1->rsa, NULL);
-	ASSERT_PTR_NE(k1->rsa->n, NULL);
-	ASSERT_PTR_NE(k1->rsa->e, NULL);
-	ASSERT_PTR_NE(k1->rsa->p, NULL);
 	ASSERT_INT_EQ(sshkey_add_private(k1), 0);
 	sshkey_free(k1);
 	TEST_DONE();
@@ -255,8 +244,6 @@ sshkey_tests(void)
 	k1 = sshkey_new_private(KEY_DSA);
 	ASSERT_PTR_NE(k1, NULL);
 	ASSERT_PTR_NE(k1->dsa, NULL);
-	ASSERT_PTR_NE(k1->dsa->g, NULL);
-	ASSERT_PTR_NE(k1->dsa->priv_key, NULL);
 	ASSERT_INT_EQ(sshkey_add_private(k1), 0);
 	sshkey_free(k1);
 	TEST_DONE();
@@ -295,18 +282,13 @@ sshkey_tests(void)
 	ASSERT_INT_EQ(sshkey_generate(KEY_RSA, 1024, &kr), 0);
 	ASSERT_PTR_NE(kr, NULL);
 	ASSERT_PTR_NE(kr->rsa, NULL);
-	ASSERT_PTR_NE(kr->rsa->n, NULL);
-	ASSERT_PTR_NE(kr->rsa->e, NULL);
-	ASSERT_PTR_NE(kr->rsa->p, NULL);
-	ASSERT_INT_EQ(BN_num_bits(kr->rsa->n), 1024);
+	ASSERT_INT_EQ(RSA_bits(kr->rsa), 1024);
 	TEST_DONE();
 
 	TEST_START("generate KEY_DSA");
 	ASSERT_INT_EQ(sshkey_generate(KEY_DSA, 1024, &kd), 0);
 	ASSERT_PTR_NE(kd, NULL);
 	ASSERT_PTR_NE(kd->dsa, NULL);
-	ASSERT_PTR_NE(kd->dsa->g, NULL);
-	ASSERT_PTR_NE(kd->dsa->priv_key, NULL);
 	TEST_DONE();
 
 #ifdef OPENSSL_HAS_ECC
@@ -333,9 +315,6 @@ sshkey_tests(void)
 	ASSERT_PTR_NE(kr, k1);
 	ASSERT_INT_EQ(k1->type, KEY_RSA);
 	ASSERT_PTR_NE(k1->rsa, NULL);
-	ASSERT_PTR_NE(k1->rsa->n, NULL);
-	ASSERT_PTR_NE(k1->rsa->e, NULL);
-	ASSERT_PTR_EQ(k1->rsa->p, NULL);
 	TEST_DONE();
 
 	TEST_START("equal KEY_RSA/demoted KEY_RSA");
@@ -349,8 +328,6 @@ sshkey_tests(void)
 	ASSERT_PTR_NE(kd, k1);
 	ASSERT_INT_EQ(k1->type, KEY_DSA);
 	ASSERT_PTR_NE(k1->dsa, NULL);
-	ASSERT_PTR_NE(k1->dsa->g, NULL);
-	ASSERT_PTR_EQ(k1->dsa->priv_key, NULL);
 	TEST_DONE();
 
 	TEST_START("equal KEY_DSA/demoted KEY_DSA");

diff -up openssh-7.4p1/ssh-agent.c.openssl openssh-7.4p1/ssh-agent.c
--- openssh-7.4p1/ssh-agent.c.openssl	2016-12-23 17:47:36.428817751 +0100
+++ openssh-7.4p1/ssh-agent.c	2016-12-23 17:47:36.434817754 +0100
@@ -258,12 +258,12 @@ process_request_identities(SocketEntry *
 	TAILQ_FOREACH(id, &tab->idlist, next) {
 		if (id->key->type == KEY_RSA1) {
 #ifdef WITH_SSH1
+			const BIGNUM *r_n, *r_e;
+			RSA_get0_key(id->key->rsa, &r_n, &r_e, NULL);
 			if ((r = sshbuf_put_u32(msg,
-			    BN_num_bits(id->key->rsa->n))) != 0 ||
-			    (r = sshbuf_put_bignum1(msg,
-			    id->key->rsa->e)) != 0 ||
-			    (r = sshbuf_put_bignum1(msg,
-			    id->key->rsa->n)) != 0)
+			    BN_num_bits(r_n))) != 0 ||
+			    (r = sshbuf_put_bignum1(msg, r_e)) != 0 ||
+			    (r = sshbuf_put_bignum1(msg, r_n)) != 0)
 				fatal("%s: buffer error: %s",
 				    __func__, ssh_err(r));
 #endif
@@ -302,6 +302,7 @@ process_authentication_challenge1(Socket
 	struct sshbuf *msg;
 	struct ssh_digest_ctx *md;
 	struct sshkey *key;
+	BIGNUM *r_n = NULL, *r_e = NULL;
 
 	if ((msg = sshbuf_new()) == NULL)
 		fatal("%s: sshbuf_new failed", __func__);
@@ -310,11 +311,16 @@ process_authentication_challenge1(Socket
 	if ((challenge = BN_new()) == NULL)
 		fatal("%s: BN_new failed", __func__);
 
-	if ((r = sshbuf_get_u32(e->request, NULL)) != 0 || /* ignored */
-	    (r = sshbuf_get_bignum1(e->request, key->rsa->e)) != 0 ||
-	    (r = sshbuf_get_bignum1(e->request, key->rsa->n)) != 0 ||
-	    (r = sshbuf_get_bignum1(e->request, challenge)))
+	if ((r_n = BN_new()) == NULL || (r_e = BN_new()) == NULL ||
+	    (r = sshbuf_get_u32(e->request, NULL)) != 0 || /* ignored */
+	    (r = sshbuf_get_bignum1(e->request, r_e)) != 0 ||
+	    (r = sshbuf_get_bignum1(e->request, r_n)) != 0 ||
+	    (r = sshbuf_get_bignum1(e->request, challenge)) ||
+	    RSA_set0_key(key->rsa, r_n, r_e, NULL) == 0) {
+		BN_free(r_n);
+		BN_free(r_e);
 		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	}
 
 	/* Only protocol 1.1 is supported */
 	if (sshbuf_len(e->request) == 0)
@@ -450,6 +456,7 @@ process_remove_identity(SocketEntry *e,
 	u_char *blob;
 #ifdef WITH_SSH1
 	u_int bits;
+	BIGNUM *r_n = NULL, *r_e = NULL;
 #endif /* WITH_SSH1 */
 
 	switch (version) {
@@ -459,10 +466,15 @@ process_remove_identity(SocketEntry *e,
 			error("%s: sshkey_new failed", __func__);
 			return;
 		}
-		if ((r = sshbuf_get_u32(e->request, &bits)) != 0 ||
-		    (r = sshbuf_get_bignum1(e->request, key->rsa->e)) != 0 ||
-		    (r = sshbuf_get_bignum1(e->request, key->rsa->n)) != 0)
+		if ((r_n = BN_new()) == NULL || (r_e = BN_new()) == NULL ||
+		    (r = sshbuf_get_u32(e->request, &bits)) != 0 ||
+		    (r = sshbuf_get_bignum1(e->request, r_e)) != 0 ||
+		    (r = sshbuf_get_bignum1(e->request, r_n)) != 0 ||
+		    RSA_set0_key(key->rsa, r_n, r_e, NULL) == 0) {
+			BN_free(r_n);
+			BN_free(r_e);
 			fatal("%s: buffer error: %s", __func__, ssh_err(r));
+		}
 
 		if (bits != sshkey_size(key))
 			logit("Warning: identity keysize mismatch: "
@@ -565,23 +577,38 @@ agent_decode_rsa1(struct sshbuf *m, stru
 {
 	struct sshkey *k = NULL;
 	int r = SSH_ERR_INTERNAL_ERROR;
+	BIGNUM *n = NULL, *e = NULL, *d = NULL,
+	    *iqmp = NULL, *q = NULL, *p = NULL;
 
 	*kp = NULL;
 	if ((k = sshkey_new_private(KEY_RSA1)) == NULL)
 		return SSH_ERR_ALLOC_FAIL;
 
-	if ((r = sshbuf_get_u32(m, NULL)) != 0 ||		/* ignored */
-	    (r = sshbuf_get_bignum1(m, k->rsa->n)) != 0 ||
-	    (r = sshbuf_get_bignum1(m, k->rsa->e)) != 0 ||
-	    (r = sshbuf_get_bignum1(m, k->rsa->d)) != 0 ||
-	    (r = sshbuf_get_bignum1(m, k->rsa->iqmp)) != 0 ||
+	if ((n = BN_new()) == NULL || (e = BN_new()) == NULL ||
+	    (d = BN_new()) == NULL || (iqmp = BN_new()) == NULL ||
+	    (q = BN_new()) == NULL || (p = BN_new()) == NULL ||
+	    (r = sshbuf_get_u32(m, NULL)) != 0 ||		/* ignored */
+	    (r = sshbuf_get_bignum1(m, n)) != 0 ||
+	    (r = sshbuf_get_bignum1(m, e)) != 0 ||
+	    (r = sshbuf_get_bignum1(m, d)) != 0 ||
+	    (r = sshbuf_get_bignum1(m, iqmp)) != 0 ||
 	    /* SSH1 and SSL have p and q swapped */
-	    (r = sshbuf_get_bignum1(m, k->rsa->q)) != 0 ||	/* p */
-	    (r = sshbuf_get_bignum1(m, k->rsa->p)) != 0) 	/* q */
+	    (r = sshbuf_get_bignum1(m, q)) != 0 ||	/* p */
+	    (r = sshbuf_get_bignum1(m, p)) != 0 || 	/* q */
+	    RSA_set0_key(k->rsa, n, e, d) == 0 ||
+	    RSA_set0_factors(k->rsa, p, q) == 0 ||
+	    RSA_set0_crt_params(k->rsa, NULL, NULL, iqmp) == 0) {
+		BN_free(n);
+		BN_free(e);
+		BN_free(d);
+		BN_free(p);
+		BN_free(q);
+		BN_free(iqmp);
 		goto out;
+	}
 
 	/* Generate additional parameters */
-	if ((r = rsa_generate_additional_parameters(k->rsa)) != 0)
+	if ((r = rsa_generate_additional_parameters(k->rsa, NULL)) != 0)
 		goto out;
 	/* enable blinding */
 	if (RSA_blinding_on(k->rsa, NULL) != 1) {
diff -up openssh-7.4p1/sshconnect1.c.openssl openssh-7.4p1/sshconnect1.c
--- openssh-7.4p1/sshconnect1.c.openssl	2016-12-19 05:59:41.000000000 +0100
+++ openssh-7.4p1/sshconnect1.c	2016-12-23 17:47:36.434817754 +0100
@@ -70,6 +70,7 @@ try_agent_authentication(void)
 	u_char response[16];
 	size_t i;
 	BIGNUM *challenge;
+	const BIGNUM *n;
 	struct ssh_identitylist *idlist = NULL;
 
 	/* Get connection to the agent. */
@@ -96,8 +97,9 @@ try_agent_authentication(void)
 		    idlist->comments[i]);
 
 		/* Tell the server that we are willing to authenticate using this key. */
+		RSA_get0_key(idlist->keys[i]->rsa, &n, NULL, NULL);
 		packet_start(SSH_CMSG_AUTH_RSA);
-		packet_put_bignum(idlist->keys[i]->rsa->n);
+		packet_put_bignum((BIGNUM *)n);
 		packet_send();
 		packet_write_wait();
 
@@ -220,6 +222,7 @@ static int
 try_rsa_authentication(int idx)
 {
 	BIGNUM *challenge;
+	const BIGNUM *n;
 	Key *public, *private;
 	char buf[300], *passphrase = NULL, *comment, *authfile;
 	int i, perm_ok = 1, type, quit;
@@ -231,8 +234,9 @@ try_rsa_authentication(int idx)
 	debug("Trying RSA authentication with key '%.100s'", comment);
 
 	/* Tell the server that we are willing to authenticate using this key. */
+	RSA_get0_key(public->rsa, &n, NULL, NULL);
 	packet_start(SSH_CMSG_AUTH_RSA);
-	packet_put_bignum(public->rsa->n);
+	packet_put_bignum((BIGNUM *)n);
 	packet_send();
 	packet_write_wait();
 
@@ -348,15 +352,17 @@ try_rhosts_rsa_authentication(const char
 {
 	int type;
 	BIGNUM *challenge;
+	const BIGNUM *n, *e;
 
 	debug("Trying rhosts or /etc/hosts.equiv with RSA host authentication.");
 
 	/* Tell the server that we are willing to authenticate using this key. */
+	RSA_get0_key(host_key->rsa, &n, &e, NULL);
 	packet_start(SSH_CMSG_AUTH_RHOSTS_RSA);
 	packet_put_cstring(local_user);
-	packet_put_int(BN_num_bits(host_key->rsa->n));
-	packet_put_bignum(host_key->rsa->e);
-	packet_put_bignum(host_key->rsa->n);
+	packet_put_int(BN_num_bits(n));
+	packet_put_bignum((BIGNUM *)e);
+	packet_put_bignum((BIGNUM *)n);
 	packet_send();
 	packet_write_wait();
 
@@ -502,6 +508,8 @@ ssh_kex(char *host, struct sockaddr *hos
 {
 	int i;
 	BIGNUM *key;
+	BIGNUM *server_n = NULL, *server_e = NULL,
+	    *host_n = NULL, *host_e = NULL;
 	Key *host_key, *server_key;
 	int bits, rbits;
 	int ssh_cipher_default = SSH_CIPHER_3DES;
@@ -522,10 +530,14 @@ ssh_kex(char *host, struct sockaddr *hos
 	if ((server_key = key_new(KEY_RSA1)) == NULL)
 		fatal("%s: key_new(KEY_RSA1) failed", __func__);
 	bits = packet_get_int();
-	packet_get_bignum(server_key->rsa->e);
-	packet_get_bignum(server_key->rsa->n);
+	if ((server_e = BN_new()) == NULL ||
+	    (server_n = BN_new()) == NULL)
+		fatal("BN_new() failed");
+	packet_get_bignum(server_e);
+	packet_get_bignum(server_n);
+	RSA_set0_key(server_key->rsa, server_n, server_e, NULL);
 
-	rbits = BN_num_bits(server_key->rsa->n);
+	rbits = BN_num_bits(server_n);
 	if (bits != rbits) {
 		logit("Warning: Server lies about size of server public key: "
 		    "actual size is %d bits vs. announced %d.", rbits, bits);
@@ -534,10 +546,14 @@ ssh_kex(char *host, struct sockaddr *hos
 	if ((host_key = key_new(KEY_RSA1)) == NULL)
 		fatal("%s: key_new(KEY_RSA1) failed", __func__);
 	bits = packet_get_int();
-	packet_get_bignum(host_key->rsa->e);
-	packet_get_bignum(host_key->rsa->n);
+	if ((host_e = BN_new()) == NULL ||
+	    (host_n = BN_new()) == NULL)
+		fatal("BN_new() failed");
+	packet_get_bignum(host_e);
+	packet_get_bignum(host_n);
+	RSA_set0_key(host_key->rsa, host_n, host_e, NULL);
 
-	rbits = BN_num_bits(host_key->rsa->n);
+	rbits = BN_num_bits(host_n);
 	if (bits != rbits) {
 		logit("Warning: Server lies about size of server host key: "
 		    "actual size is %d bits vs. announced %d.", rbits, bits);
@@ -553,14 +569,14 @@ ssh_kex(char *host, struct sockaddr *hos
 	packet_check_eom();
 
 	debug("Received server public key (%d bits) and host key (%d bits).",
-	    BN_num_bits(server_key->rsa->n), BN_num_bits(host_key->rsa->n));
+	    BN_num_bits(server_n), BN_num_bits(host_n));
 
 	if (verify_host_key(host, hostaddr, host_key) == -1)
 		fatal("Host key verification failed.");
 
 	client_flags = SSH_PROTOFLAG_SCREEN_NUMBER | SSH_PROTOFLAG_HOST_IN_FWD_OPEN;
 
-	derive_ssh1_session_id(host_key->rsa->n, server_key->rsa->n, cookie, session_id);
+	derive_ssh1_session_id(host_n, server_n, cookie, session_id);
 
 	/*
 	 * Generate an encryption key for the session.   The key is a 256 bit
@@ -595,14 +611,14 @@ ssh_kex(char *host, struct sockaddr *hos
 	 * Encrypt the integer using the public key and host key of the
 	 * server (key with smaller modulus first).
 	 */
-	if (BN_cmp(server_key->rsa->n, host_key->rsa->n) < 0) {
+	if (BN_cmp(server_n, host_n) < 0) {
 		/* Public key has smaller modulus. */
-		if (BN_num_bits(host_key->rsa->n) <
-		    BN_num_bits(server_key->rsa->n) + SSH_KEY_BITS_RESERVED) {
+		if (BN_num_bits(host_n) <
+		    BN_num_bits(server_n) + SSH_KEY_BITS_RESERVED) {
 			fatal("respond_to_rsa_challenge: host_key %d < server_key %d + "
 			    "SSH_KEY_BITS_RESERVED %d",
-			    BN_num_bits(host_key->rsa->n),
-			    BN_num_bits(server_key->rsa->n),
+			    BN_num_bits(host_n),
+			    BN_num_bits(server_n),
 			    SSH_KEY_BITS_RESERVED);
 		}
 		if (rsa_public_encrypt(key, key, server_key->rsa) != 0 ||
@@ -610,12 +626,12 @@ ssh_kex(char *host, struct sockaddr *hos
 			fatal("%s: rsa_public_encrypt failed", __func__);
 	} else {
 		/* Host key has smaller modulus (or they are equal). */
-		if (BN_num_bits(server_key->rsa->n) <
-		    BN_num_bits(host_key->rsa->n) + SSH_KEY_BITS_RESERVED) {
+		if (BN_num_bits(server_n) <
+		    BN_num_bits(host_n) + SSH_KEY_BITS_RESERVED) {
 			fatal("respond_to_rsa_challenge: server_key %d < host_key %d + "
 			    "SSH_KEY_BITS_RESERVED %d",
-			    BN_num_bits(server_key->rsa->n),
-			    BN_num_bits(host_key->rsa->n),
+			    BN_num_bits(server_n),
+			    BN_num_bits(host_n),
 			    SSH_KEY_BITS_RESERVED);
 		}
 		if (rsa_public_encrypt(key, key, host_key->rsa) != 0 ||
diff -up openssh-7.4p1/sshconnect2.c.openssl openssh-7.4p1/sshconnect2.c
--- openssh-7.4p1/sshconnect2.c.openssl	2016-12-23 17:47:36.423817749 +0100
+++ openssh-7.4p1/sshconnect2.c	2016-12-23 17:47:36.434817754 +0100
@@ -299,6 +299,7 @@ ssh_kex2(char *host, struct sockaddr *ho
 	packet_send();
 	packet_write_wait();
 #endif
+	/* XXX free myproposal ?? */
 }
 
 /*
diff -up openssh-7.4p1/sshconnect.c.openssl openssh-7.4p1/sshconnect.c
--- openssh-7.4p1/sshconnect.c.openssl	2016-12-23 17:47:36.397817738 +0100
+++ openssh-7.4p1/sshconnect.c	2016-12-23 17:47:36.435817754 +0100
@@ -1369,6 +1369,7 @@ ssh_login(Sensitive *sensitive, const ch
 	char *server_user, *local_user;
 
 	local_user = xstrdup(pw->pw_name);
+	free(pw);
 	server_user = options.user ? options.user : local_user;
 
 	/* Convert the user-supplied hostname into all lowercase. */
diff -up openssh-7.4p1/ssh.c.openssl openssh-7.4p1/ssh.c
--- openssh-7.4p1/ssh.c.openssl	2016-12-23 17:47:36.422817748 +0100
+++ openssh-7.4p1/ssh.c	2016-12-23 17:47:36.435817754 +0100
@@ -532,7 +532,9 @@ main(int ac, char **av)
 	sanitise_stdfd();
 
 	__progname = ssh_get_progname(av[0]);
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
         SSLeay_add_all_algorithms();
+#endif
 	if (access("/etc/system-fips", F_OK) == 0)
 		if (! FIPSCHECK_verify(NULL, NULL)){
 			if (FIPS_mode())
@@ -1247,6 +1249,7 @@ main(int ac, char **av)
 		free(cp);
 	}
 	free(conn_hash_hex);
+	free(host_arg);
 
 	if (config_test) {
 		dump_client_config(&options, host);
diff -up openssh-7.4p1/sshd.c.openssl openssh-7.4p1/sshd.c
--- openssh-7.4p1/sshd.c.openssl	2016-12-23 17:47:36.428817751 +0100
+++ openssh-7.4p1/sshd.c	2016-12-23 17:47:36.435817754 +0100
@@ -1483,7 +1483,7 @@ main(int ac, char **av)
 #endif
 	__progname = ssh_get_progname(av[0]);
 
-        SSLeay_add_all_algorithms();
+	OpenSSL_add_all_algorithms();
 	if (access("/etc/system-fips", F_OK) == 0)
 		if (! FIPSCHECK_verify(NULL, NULL)) {
 			openlog(__progname, LOG_PID, LOG_AUTHPRIV);

 
diff -up openssh-7.4p1/ssh-keyscan.c.openssl openssh-7.4p1/ssh-keyscan.c
--- openssh-7.4p1/ssh-keyscan.c.openssl	2016-12-23 17:47:36.325817708 +0100
+++ openssh-7.4p1/ssh-keyscan.c	2016-12-23 17:47:36.437817755 +0100
@@ -195,6 +195,7 @@ keygrab_ssh1(con *c)
 	static struct sshbuf *msg;
 	int r;
 	u_char type;
+	BIGNUM *n = NULL, *e = NULL;
 
 	if (rsa == NULL) {
 		if ((rsa = sshkey_new(KEY_RSA1)) == NULL) {
@@ -213,16 +214,20 @@ keygrab_ssh1(con *c)
 		sshbuf_reset(msg);
 		return NULL;
 	}
-	if ((r = sshbuf_consume(msg, 8)) != 0 || /* cookie */
+	if ((n = BN_new()) == NULL || (e = BN_new()) == NULL || 
+	    (r = sshbuf_consume(msg, 8)) != 0 || /* cookie */
 	    /* server key */
 	    (r = sshbuf_get_u32(msg, NULL)) != 0 ||
 	    (r = sshbuf_get_bignum1(msg, NULL)) != 0 ||
 	    (r = sshbuf_get_bignum1(msg, NULL)) != 0 ||
 	    /* host key */
 	    (r = sshbuf_get_u32(msg, NULL)) != 0 ||
-	    (r = sshbuf_get_bignum1(msg, rsa->rsa->e)) != 0 ||
-	    (r = sshbuf_get_bignum1(msg, rsa->rsa->n)) != 0) {
+	    (r = sshbuf_get_bignum1(msg, e)) != 0 ||
+	    (r = sshbuf_get_bignum1(msg, n)) != 0 ||
+	    RSA_set0_key(rsa->rsa, n, e, NULL) == 0) {
  buf_err:
+		BN_free(n);
+		BN_free(e);
 		error("%s: buffer error: %s", __func__, ssh_err(r));
 		sshbuf_reset(msg);
 		return NULL;
 
 
diff --git a/sshkey.c b/sshkey.c
index ffc17ce..130217a 100644
--- a/sshkey.c
+++ b/sshkey.c
@@ -3815,7 +3815,9 @@ sshkey_parse_private_pem_fileblob(struct sshbuf *blob, int type,
 			case EVP_R_BAD_DECRYPT:
 				r = SSH_ERR_KEY_WRONG_PASSPHRASE;
 				goto out;
+#ifdef EVP_R_BN_DECODE_ERROR
 			case EVP_R_BN_DECODE_ERROR:
+#endif
 			case EVP_R_DECODE_ERROR:
 #ifdef EVP_R_PRIVATE_KEY_DECODE_ERROR
 			case EVP_R_PRIVATE_KEY_DECODE_ERROR:

generated by cgit v1.1 at 2017-05-05 15:00:07 +0000
